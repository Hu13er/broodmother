package httpgen

import (
	"bytes"
	"fmt"
	"go/build"
	"go/format"
	"path"
	"strings"
	"text/template"

	"github.com/Hu13er/broodmother"
)

var clientTemplate = `// Generated by broodmother.httpgen
// Do NOT edit this file.

package client

import (
    "net/http"
    "encoding/json"
    "bytes"

    core "{{.CorePkg}}"
    httppkg "{{.HttpPkg}}"
    {{range .Imports}}
    {{.}}{{end}}
)

type Client struct {
    Addr string
    Err  error
}

var _ core.{{.CoreType}} = (*Client)(nil)

{{range .Funcs}}
func (client *Client) {{.Name}}(
    {{range .Params}}{{.Name}} {{.Type}},
    {{end}}
) (
    {{range .Results}}{{.Name}} {{.Type}},
    {{end}}
) {
    reqjson := httppkg.{{call $.CamelCase .Name}}JSONRequest{
        {{range .Params}}{{call $.CamelCase .Name}}: {{.Name}},
        {{end}}
    }

    reqbuf := &bytes.Buffer{}
    if jerr := json.NewEncoder(reqbuf).Encode(reqjson); jerr != nil {
        client.Err = jerr
        return
    }

    resp, rerr := http.Post(client.Addr + "/{{.Path}}", "application/json", reqbuf)
    if rerr != nil {
        client.Err = rerr
        return
    }

    respjson := httppkg.{{call $.CamelCase .Name}}JSONResponses{
        {{range .Results}}{{call $.CamelCase .Name}}: {{.Name}},
        {{end}}
    }
    if jerr := json.NewDecoder(resp.Body).Decode(&respjson); jerr != nil {
        client.Err = jerr
        return
    }

    {{range .Results}}{{.Name}} = respjson.{{call $.CamelCase .Name}}
    {{end}}
    return
}

{{end}}
`

func (g *HttpGen) genClient(ctx broodmother.Context) string {
	t := template.Must(template.New("httpgen").Parse(clientTemplate))
	imports := make(map[string]string)
	// TODO: we should use go/build package for
	// checking imports.
	// Now, this code assumes that folder name and
	// package name are same thing.
	// TODO: check for map and slices types.
	checkForImport := func(inp string) string {
		splited := strings.SplitN(inp, ".", 2)
		if len(splited) <= 1 {
			internalTypes := []string{
				"bool",
				"int", "int8", "int16", "int32", "int64",
				"uint", "uint8", "uint16", "uint32", "uint64",
				"float32", "float64",
				"string",
				"error",
			}
			isInternal := false
			for _, t := range internalTypes {
				if t == inp {
					isInternal = true
					break
				}
			}
			if isInternal {
				return inp
			}
			// Already imported core.
			return "core." + inp
		}
		pkg := splited[0]
		for p, n := range ctx.Imports() {
			if n == "" {
				n = path.Base(p)
			}
			if n == pkg {
				imports[p] = n
			}
		}
		return inp
	}
	stringImports := func() []string {
		outp := make([]string, 0)
		for p, n := range imports {
			if path.Base(p) == n {
				outp = append(outp, fmt.Sprintf("%q", p))
			} else {
				outp = append(outp, fmt.Sprintf("%s %q", n, p))
			}
		}
		return outp
	}

	type dec struct {
		Name string
		Type string
	}
	type fn struct {
		Name    string
		Params  []dec
		Results []dec
		Path    string
	}

	fns := make([]fn, 0)
	for _, f := range g.funcs {
		ff := fn{}
		ff.Name = f.name
		for _, p := range f.params {
			p.typ = checkForImport(p.typ)
			ff.Params = append(ff.Params, dec{
				Name: p.name,
				Type: p.typ,
			})
		}
		for _, r := range f.result {
			r.typ = checkForImport(r.typ)
			ff.Results = append(ff.Results, dec{
				Name: r.name,
				Type: r.typ,
			})
		}
		ff.Path = broodmother.SnakeCase(f.name)
		fns = append(fns, ff)
	}
	httpPkg := strings.TrimPrefix(g.serverPath,
		build.Default.GOPATH+"/src/")

	buf := &bytes.Buffer{}
	err := t.Execute(buf, struct {
		Imports  []string
		CoreType string
		CorePkg  string
		HttpPkg  string
		Funcs    []fn

		CamelCase    func(string) string
		AllCamelCase func([]string) []string
		AllPrefix    func(string, []string) []string
		Join         func(string, []string) string
	}{
		Imports:  stringImports(),
		CorePkg:  g.coreImport,
		CoreType: g.coreTypeName,
		HttpPkg:  httpPkg,
		Funcs:    fns,

		CamelCase: func(s string) string {
			return broodmother.CamelCase(s, true)
		},
		AllCamelCase: func(ary []string) []string {
			outp := make([]string, len(ary))
			for i, s := range ary {
				outp[i] = broodmother.CamelCase(s, true)
			}
			return outp
		},
		AllPrefix: func(prefix string, ary []string) []string {
			outp := make([]string, len(ary))
			for i, s := range ary {
				outp[i] = prefix + s
			}
			return outp
		},
		Join: func(sep string, ary []string) string {
			return strings.Join(ary, sep)
		},
	})
	if err != nil {
		panic(err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	return string(formatted)
}
