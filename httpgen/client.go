package httpgen

import (
	"bytes"
	"go/build"
	"go/format"
	"strings"
	"text/template"

	"gitlab.com/pirates1/broodmother"
)

var clientTemplate = `
// Generated by broodmother.httpgen
// Do NOT edit this file.

package client

import (
    "net/http"
    "encoding/json"
    "bytes"

    core "{{.CorePkg}}"
    httppkg "{{.HttpPkg}}"
    {{range .Imports}}
    {{.}}{{end}}
)

type Client struct {
    Addr string
    Err  error
}

var _ core.{{.CoreType}} = (*Client)(nil)

{{range .Funcs}}
func (client *Client) {{.Name}}(
    {{range .Params}}{{.Name}} {{.Type}},
    {{end}}
) (
    {{range .Results}}{{.Name}} {{.Type}},
    {{end}}
) {
    reqjson := httppkg.{{call $.CamelCase .Name}}JSONRequest{
        {{range .Params}}{{call $.CamelCase .Name}}: {{.Name}},
        {{end}}
    }

    reqbuf := &bytes.Buffer{}
    if jerr := json.NewEncoder(reqbuf).Encode(reqjson); jerr != nil {
        client.Err = jerr
        return
    }

    resp, rerr := http.Post(client.Addr + "/{{.Path}}", "application/json", reqbuf)
    if rerr != nil {
        client.Err = rerr
        return
    }

    respjson := httppkg.{{call $.CamelCase .Name}}JSONResponses{
        {{range .Results}}{{call $.CamelCase .Name}}: {{.Name}},
        {{end}}
    }
    if jerr := json.NewDecoder(resp.Body).Decode(&respjson); jerr != nil {
        client.Err = jerr
        return
    }

    {{range .Results}}{{.Name}} = respjson.{{call $.CamelCase .Name}}
    {{end}}
    return
}

{{end}}
`

func (g *HttpGen) genClient(ctx broodmother.Context) string {
	t := template.Must(template.New("httpgen").Parse(clientTemplate))

	type dec struct {
		Name string
		Type string
	}
	type fn struct {
		Name    string
		Params  []dec
		Results []dec
		Path    string
	}

	fns := make([]fn, 0)
	for _, f := range g.funcs {
		ff := fn{}
		ff.Name = f.name
		for _, p := range f.params {
			ff.Params = append(ff.Params, dec{
				Name: p.name,
				Type: p.typ,
			})
		}
		for _, r := range f.result {
			ff.Results = append(ff.Results, dec{
				Name: r.name,
				Type: r.typ,
			})
		}
		ff.Path = broodmother.SnakeCase(f.name)
		fns = append(fns, ff)
	}
	httpPkg := strings.TrimPrefix(g.serverPath,
		build.Default.GOPATH+"/src/")

	buf := &bytes.Buffer{}
	err := t.Execute(buf, struct {
		Imports  []string
		CoreType string
		CorePkg  string
		HttpPkg  string
		Funcs    []fn

		CamelCase    func(string) string
		AllCamelCase func([]string) []string
		AllPrefix    func(string, []string) []string
		Join         func(string, []string) string
	}{
		Imports:  []string{},
		CorePkg:  g.coreImport,
		CoreType: g.coreTypeName,
		HttpPkg:  httpPkg,
		Funcs:    fns,

		CamelCase: func(s string) string {
			return broodmother.CamelCase(s, true)
		},
		AllCamelCase: func(ary []string) []string {
			outp := make([]string, len(ary))
			for i, s := range ary {
				outp[i] = broodmother.CamelCase(s, true)
			}
			return outp
		},
		AllPrefix: func(prefix string, ary []string) []string {
			outp := make([]string, len(ary))
			for i, s := range ary {
				outp[i] = prefix + s
			}
			return outp
		},
		Join: func(sep string, ary []string) string {
			return strings.Join(ary, sep)
		},
	})
	if err != nil {
		panic(err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	return string(formatted)
}
